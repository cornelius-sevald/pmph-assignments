PMPH Assignment 1
===============

By: Cornelius Sevald-Krause `<lgx292>`  
Due: 2022-09-15

Task 1
------

### Part a)

Let `a, b, c` be elements of `Img(h)` such that `h x = a`, `h y = b` and
`h z = c` where `x, y, z` are elements of the domain of `h`.

To prove that '`o`' is associative we write the expression `(a o b) o c` as
`(h x o h y) o h z`. Using the third definition of `h` we re-write it
`h (x ++ y) o h z = h (x ++ y) ++ z`.
As list concatenation is associative, we can further re-write:
```
h (x ++ y) ++ z     =
h x ++ (y ++ z)     =
h x o h y ++ z      =
h x o (h y o h z)   =
a o (b o c)
```

To prove that `e` is the neutral element we use the first and third definitions
of `h` to write `b o e` as `h y o h [] = h y ++ [] = h y = b`.
It is also easy to see that `b o e = h y ++ [] = h [] ++ y = e o b`.

### Part b)

As `reduce (++) [] . distr_p` is the identity function we can write
`reduce (+) 0 . map f` as `reduce (+) 0 . map f . reduce (++) [] . distr_p`.
Using the second, third and first lemma (in that order) we get:
```
reduce (+) 0 . reduce (++) [] . map (map f) . distr_p       =
reduce (+) 0 . map (reduce (+) 0) . map (map f) . distr_p   =
reduce (+) 0 . map ( (reduce (+) 0) . (map f) ) . distr_p   =
```

Task 2
------

### Solution

The solution added to `lssp.fut` is shown below (line 21-25):
```futhark
let connect= tlx == 0 || tly == 0 || pred2 lastx firsty
let newlss = max (max (lssx, lssy), if connect then (lcsx + lisy) else 0)
let newlis = if lisx == tlx && connect then lisx + lisy else lisx
let newlcs = if lcsy == tly && connect then lcsx + lcsy else lcsy
let newtl  = tlx + tly
```

### Test cases

The following test cases were added.  
for `lssp-same.fut`:
```
compiled input {
   [0i32, 1, 2, 3, 4, 5, 6, 7, 8, 9]
}
output {
   1
}
compiled input {
   [1i32, 2, 2, 4, 4, 4, 4, 3, 3, 3]
}
output {
   4
}
```

for `lssp-zeros.fut`:
```
compiled input {
   [0i32, 1, 2, 3, 4, 5, 6, 7, 8, 9]
}
output {
   1
}
compiled input {
   [1i32, 2, 2, 4, 4, 4, 4, 3, 3, 3]
}
output {
   0
}
```

for `lssp-sorted.fut`:
```
compiled input {
   [0i32, 1, 2, 3, 4, 5, 6, 7, 8, 9]
}
output {
   10
}
compiled input {
   [9i32, 8, 7, 6, 5, 4, 3, 2, 1, 0]
}
output {
   1
}
```

### Speedup

The benchmarks are generated by running
`futhark dataset --i32-bounds=-10:10 -b -g [10000000]i32`
and piping it into `./$prog -t /dev/stderr -r 10`
where `$prog` is one of `lssp-same`, `lssp-sorted` and `lssp-zeros`.
The average is then taken of the ten reported values.

The reported speed of `lssp-same`, `lssp-sorted` and `lssp-zeros` respectively,
**without** acceleration is:
```
24445
24579
18240
```

The reported speed **with** acceleration is:
```
2943
2966
2946
```

giving a speedup of approx. `8.31`, `8.29` and `6.19` respectively.
